<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 关于 ViewBinding 的二三事 · 文钦的朝花夕拾</title><meta name="description" content="关于 ViewBinding 的二三事 - 文钦"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/lewis.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="文钦的朝花夕拾"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/lewis.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/wenqin-231" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://wenqin231@gmail.com" target="_blank" class="nav-list-link">EMAIL</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">关于 ViewBinding 的二三事</h1><div class="post-info">Apr 13, 2020</div><div class="post-content"><p><img src="https://i.loli.net/2020/04/11/9vzHZi6IBTcgNtA.png" alt="ViewBinding.png"></p>
<p><strong>ViewBinding</strong> 是 Android Studio 3.6 推出的新工具，可以用来轻松高效地编写与 View 交互的代码。在启用后，根据 XML 布局文件会生成对应的 binding 类，这个类包含了布局内所有设置过 id 的 View 的引用。</p>
<p>官方推荐使用它来替代 <code>findVeiwById</code> ；<a href="https://twitter.com/JakeWharton" target="_blank" rel="noopener">Jake Wharton</a> 也在社交平台上推荐它替换 <code>ButterKnife</code>；在 kotlin中常用的 <code>Kotlin Synthetics</code> 又有什么比不上它的呢？它本身会不会有什么坑？让我们展开讲讲。</p>
<a id="more"></a>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>相比于传统的 <code>findViewById</code>，<code>ViewBinding</code> 最直观的优势是减少代码量。对于追求效（lan）率（duo）的工程师来说，这是最吸引人的地方。</p>
<p>虽然 <code>ButterKnife</code> 也可以通过插件做到这点，但是那些 <code>@BindView</code> 还是实打实地存在你的代码中，并且以后每增减一个 widget，你都需要考虑那些绑定关系。而 <code>ViewBinding</code> 是动态生效的，在你的 XML 布局文件添加完新的 widget 后，<code>ViewBinding</code> 类就可以调用它了😝</p>
<p><img src="https://i.loli.net/2020/04/13/S17cR4a3olGwxVs.jpg" alt="happy.jpg"></p>
<p>有朋友可能会说了，<code>Kotlin Synthetics</code> 同样也减少了很多代码量呢！跟你这个 <code>ViewBinding</code> 比起来，它不香么？那这里就不得不提到 <code>ViewBinding</code> 的第二个优势了——安全。</p>
<p>我们知道，<code>Kotlin Synthetics</code> 是可以通过 View 或者 Activity 引用到任意 XML 中的 widget，如果不小心引用错就会导致应用 crash。而且这种异常在编译期还没法被发现，只有程序运行到使用错误的地方才会出现，这就给应用留下了安全隐患⚠️</p>
<p>而 ViewBinding 则不具备这样的问题，它保证了你只能调用对应 XML 布局文件的 widget，相对来说更安全。而且它兼容 Java，这对于还有部分代码没迁移到 Kotlin 的代码来说，也是比较友好的。</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:center">ViewBinding</th>
<th style="text-align:center">ButterKnife</th>
<th style="text-align:center">Kotlin Synthetics</th>
<th style="text-align:center">findViewById</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">空安全</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">⛔️</td>
<td style="text-align:center">⛔️</td>
</tr>
<tr>
<td style="text-align:left">保证引用是来自<br>XML 布局文件</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">⛔️</td>
<td style="text-align:center">⛔️</td>
<td style="text-align:center">⛔️</td>
</tr>
<tr>
<td style="text-align:left">支持 Kotlin 和 Java</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">⛔️</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:left">代码量</td>
<td style="text-align:center">❤️</td>
<td style="text-align:center">💔</td>
<td style="text-align:center">❤️</td>
<td style="text-align:center">💔</td>
</tr>
</tbody>
</table>
<blockquote>
<p>尽管 ButterKnife 有保护 View 的空安全，但是它不能保证 id 是不是来自于声明的 xml</p>
</blockquote>
<p>那又有朋友会问，你这个是不是跟 <code>DataBinding</code> 一样呀！我用了 <code>DataBinding</code> 是不是就不需要它了呀？</p>
<p>虽然他们两者都是生成 Binding 类，但是 <code>ViewBinding</code> 更倾向于在简单的场景下使用， 因此它相对于 <code>DataBinding</code>  来说：</p>
<ul>
<li>无需注解，编译时间更快</li>
<li>使用方便，因为它不需要对 XML 布局文件进行特殊标志，所以在项目里启动它非常方便</li>
</ul>
<p>当然，比起 <code>DataBinding</code> 它也有些限制：</p>
<ul>
<li>不支持布局变量和布局表达式，所以它不能从 XML 布局文件中获取数据动态更新 UI</li>
<li>不支持双向数据绑定</li>
</ul>
<p>因此，你可以同时支持 <code>ViewBinding</code> 和 <code>DataBinding</code>。如果需要额外的特性，你可以让 <code>DataBinding</code> 来完成，而简单的应用就交给 <code>ViewBinding</code></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在 <code>build.gradle</code> 中声明使用 <code>ViewBinding</code></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Android Studio 3.6</span></span><br><span class="line">android &#123;</span><br><span class="line">    viewBinding &#123;</span><br><span class="line">        enabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在 Android Stduio 4.0 中，<code>ViewBinding</code> 已经移入<code>buildFeatures</code> 中了</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Android Studio 4.0</span></span><br><span class="line">android &#123;</span><br><span class="line">    buildFeatures &#123;</span><br><span class="line">        viewBinding = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明后，根据你的 xml 命名动态生成 **Binding，例如 activity_home 就会生成 ActivityHomeBinding</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityHomeBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    binding = ActivityHomeBinding.inflate(layoutInflater)</span><br><span class="line">    <span class="keyword">val</span> view = binding.root</span><br><span class="line">    setContentView(view)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你已经 inflate 了 xml，那也可以使用 <code>bind(view)</code> 将 <code>ViewBinding</code> 和 View 绑定，这便于我们对自定义 View 进行重构。</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>从去年年底开始，我就在 Android Studio 3.6 preview 版本上使用 <code>ViewBinding</code> 开发了。下面分享一下项目内的实践思路。</p>
<h4 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h4><p>最经常使用的 Fragment，我创建了 BindingFragment，继承于项目里原来的 <code>BaseFragment</code>，让 Binding 的业务尽量不影响原来的封装。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingFragment</span>&lt;<span class="type">T : ViewBinding</span>&gt; : <span class="type">BaseFragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: View? &#123;</span><br><span class="line">        initData().invoke(arguments ?: Bundle())</span><br><span class="line">        binding = createBinding().invoke(inflater, container, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> binding.root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">        setupView().invoke(binding)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">createBinding</span><span class="params">()</span></span>: (</span><br><span class="line">        inflater: LayoutInflater,</span><br><span class="line">        container: ViewGroup?,</span><br><span class="line">        attachToRoot: <span class="built_in">Boolean</span></span><br><span class="line">    ) -&gt; T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">initData</span><span class="params">()</span></span>: Bundle.() -&gt; <span class="built_in">Unit</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">setupView</span><span class="params">()</span></span>: T.() -&gt; <span class="built_in">Unit</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">ctx</span><span class="params">()</span></span>: Context = binding.root.context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类使用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeFragment</span> : <span class="type">BindingFragment</span>&lt;<span class="type">FragmentHomeBinding</span>&gt;</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createBinding</span><span class="params">()</span></span>: (</span><br><span class="line">        inflater: LayoutInflater,</span><br><span class="line">        container: ViewGroup?,</span><br><span class="line">        attachToRoot: <span class="built_in">Boolean</span></span><br><span class="line">    ) -&gt; FragmentHomeBinding &#123;</span><br><span class="line">        <span class="keyword">return</span> FragmentHomeBinding::inflate</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setupView</span><span class="params">()</span></span>: FragmentHomeBinding.() -&gt; <span class="built_in">Unit</span> = &#123;</span><br><span class="line">        tvContent.text = <span class="string">"ViewBinding is cool"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于子类，我只需要关心 <code>fragment_home.xml</code> 生成的 <code>FragmentHomeBinding</code>，不需要额外对 <code>R.layout.fragment_home</code> 进行处理。在 <code>setupView</code> 中我可以直接使用 <code>tvContent</code>  的引用，就像在使用 <code>kotlin Synthetics</code> 一样。</p>
<h4 id="View"><a href="#View" class="headerlink" title="View"></a>View</h4><p>自定义 View 也是经常使用的，这里有两种使用思路</p>
<p>先用 <code>View#inflate</code> 绑定 XML 后，再用 <code>ViewBinding#bind</code> 绑定 View，这样就可以使用 <code>ViewBinding</code> 来渲染相应的 UI，这种方式方便我们重构已经写好的 View：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmptyView</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    context: Context, attrs: AttributeSet? = <span class="literal">null</span>, defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : ConstraintLayout(context, attrs, defStyleAttr) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> binding: ViewEmptyBinding</span><br><span class="line">    </span><br><span class="line">    init &#123;</span><br><span class="line">        View.inflate(context, R.layout.view_empty, <span class="keyword">this</span>)</span><br><span class="line">        binding = ViewEmptyBinding.bind(<span class="keyword">this</span>)</span><br><span class="line">        binding.apply &#123;</span><br><span class="line">            tvTitle.text = <span class="string">"Data is emtpy"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种是使用 <code>ViewBinding#inflate</code>，这种就不用关心 <code>R.layout.view_emty</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmptyView</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    context: Context, attrs: AttributeSet? = <span class="literal">null</span>, defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : ConstraintLayout(context, attrs, defStyleAttr) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> binding = ViewEmptyBinding.inflate(LayoutInflater.from(context), <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        binding.apply &#123;</span><br><span class="line">            tvTitle.text = <span class="string">"Data is emtpy"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h4><p>项目里的 Adapter 是基于第三方库进行封装的，这里提供一种基于 <code>RecyclerView.Adapter</code> 的封装作为参考：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingViewHolder</span>&lt;<span class="type">VB : ViewBinding</span>&gt;</span>(<span class="keyword">val</span> vb: VB) : RecyclerView.ViewHolder(vb.root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingAdapter</span>&lt;<span class="type">VB : ViewBinding, T</span>&gt; : <span class="type">RecyclerView.Adapter</span>&lt;<span class="type">BindingViewHolder&lt;VB</span>&gt;&gt;</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: MutableList&lt;T&gt; = arrayListOf()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: BindingViewHolder&lt;VB&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingViewHolder(</span><br><span class="line">            createBinding().invoke(LayoutInflater.from(parent.context), parent, <span class="literal">false</span>)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> = <span class="keyword">data</span>.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">BindingViewHolder</span>&lt;<span class="type">VB</span>&gt;, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">data</span>.getOrNull(position)?.apply &#123; </span><br><span class="line">            update(<span class="keyword">this</span>).invoke(holder.vb)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">createBinding</span><span class="params">()</span></span>: (</span><br><span class="line">        inflater: LayoutInflater,</span><br><span class="line">        container: ViewGroup?,</span><br><span class="line">        attachToRoot: <span class="built_in">Boolean</span></span><br><span class="line">    ) -&gt; VB</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(item: <span class="type">T</span>)</span></span>: VB.() -&gt; <span class="built_in">Unit</span> = &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现思路也是和 Fragment 类似的，Adapter 的子类是需要是实现 <code>createBinding</code> 就可以实现相应的逻辑。这里仅提供一个简单的例子，目前这个封装还解决不了多布局的问题。如果需要解决多布局的问题还需要基于 ViewHolder 进行封装，聪明的你能想出来么？</p>
<blockquote>
<p>每个项目都有自己封装的关于 Adapter 类，这边提供的是封装思路仅为抛砖引玉。这里奉上我<a href="https://gist.github.com/wenqin-231/70ee973b6d130e7e247360ee6d6021ad" target="_blank" rel="noopener">基于 ViewHolder 的封装</a>，有更好的想法欢迎与我讨论</p>
</blockquote>
<p>看完了我们上面三个的封装，你会发现，我尽量都是让 ViewBinding 去替换掉我原先使用 <code>R.layout.xxx</code> 的地方，让调用方只关心 ViewBinding 就可以写好代码。不好的地方就是 lint 检查的时候会发现我有大量的 xml 没有使用😂</p>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>前面是聊了这么久 ViewBinding 的优点，我们再来讲讲它的缺点：</p>
<ul>
<li>调用方式的不友好<ul>
<li>与 <code>kotlin synthetics</code> 相比，widget 的引用要依赖于 binding 的实例，但可以用 apply 或者 run 来缓解</li>
</ul>
</li>
<li>inlcude 标签不友好<ul>
<li>使用其他方式，即便我们不给 include 加 id，也可以正常使用。而 <code>Viewbinding</code> 你得使用 <code>binding.inlcdeId.widgetId</code> 来获得 widget 的引用。如果 include 里面还有 inlcude ，就只能不停地套娃🙄</li>
<li>inlcude 如果使用了 merge 标签，你还得 <code>MyInlcudeLayoutBinding.bind(binding.includeId)</code> 来绑定，否则会报错</li>
</ul>
</li>
<li>重复命名不友好<ul>
<li>如果一个 id 的命名和 inlcude 或者自定义 View 内部的命名相同，那么这个 widget 的引用将会失效，而且程序不会崩溃🤦‍♀️，这种隐藏的问题只有程序运行到那里并且发现 UI 异常才能被发现😭</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对我来说，<code>ViewBinding</code> 还是蛮甜的，由于是 Binding 的引用，每处的调用我会相对比较有安全感，不用担心代码的出错。经过半年的实践开发，也没有遇到比较大的坑，推荐在实际项目中使用😝</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/03/10/大图加载器 TileView 实践探索（上）/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2020 <a href="http://yoursite.com">文钦</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>