<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 关于 ViewBinding 的二三事 · 文钦的朝花夕拾</title><meta name="description" content="关于 ViewBinding 的二三事 - 文钦"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/lewis.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="文钦的朝花夕拾"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/lewis.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/wenqin-231" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="https://wenqin231@gmail.com" target="_blank" class="nav-list-link">EMAIL</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">关于 ViewBinding 的二三事</h1><div class="post-info">Apr 13, 2020</div><div class="post-content"><p><img src="https://i.loli.net/2020/04/11/9vzHZi6IBTcgNtA.png" alt="ViewBinding.png"></p>
<p>随着 Android Studio 3.6 的发布， ViewBing 也进入了开发者们的视野。官方推荐使用它来替代 <code>findVeiwById</code> 、<code>BufferKnife</code> 以及 <code>Kotlin Synthetics</code> 。那么它究竟有什么优势，又有哪些缺陷，让我们展开讲讲。</p>
<a id="more"></a>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>相比于传统的 <code>findViewById</code>，<code>ViewBinding</code> 最直观的优势是减少代码量。对于追求效（lan）率（duo）的工程师来说，这是最吸引人的地方。虽然 ButterKnife 也可以通过插件做到这点，但是那些 <code>@BindView</code> 还是实打实的存在你的代码中，并且以后每新增一个 widget，你都需要考虑在代码里声明新的绑定关系。而 ViewBinding 是动态生效的，在你的 XML 添加完新的 widget 后，ViewBinding 文件就可以调用它了。</p>
<p><img src="https://i.loli.net/2020/04/13/S17cR4a3olGwxVs.jpg" alt="happy.jpg"></p>
<p>有朋友可能会说了，Kotlin Synthetics 同样也减少了很多代码量呢！跟你这个 ViewBinding 比起来，它不香么？那这里就不得不提到 ViewBinding 的第二个优势了——安全。</p>
<ul>
<li><strong>空安全</strong>：因为 ViewBinding 会对根据 XML 文件中的 ID 创建一个对 widget 的直接引用，所以不存在空对象的情况。</li>
<li><strong>类型安全</strong>：因为 ViewBinding 的引用是匹配 XML 文件中的组件，因此也不存在类型错误的情况</li>
</ul>
<p>我们知道，Kotlin Synthetics 的引用是可以在任何地方通过 View 或者 Activity 引用到任意 xml 中的 widget，只要 import 进来。因为，如果我们有相同的命名的 widget 就可以有引用错误的情况，这会引发应用 Crash。而且这种异常在编译期还没法被发现，只有程序运行到使用错误的地方才会出现，这就给应用留下了安全隐患。</p>
<p>而 ViewBinding 则不具备这样的问题，它保证了你只能调用对应 XML 文件的 widget，相对来说更加安全。而且它兼容 Java，这对于还有部分代码没迁移到 Kotlin 的代码来说，也是重大利好。</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:center">ViewBinding</th>
<th style="text-align:center">ButterKnife</th>
<th style="text-align:center">Kotlin Synthetics</th>
<th style="text-align:center">findViewById</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">空安全</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">⛔️</td>
<td style="text-align:center">⛔️</td>
</tr>
<tr>
<td style="text-align:left">保证引用是<br>来自声明的 XML</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">⛔️</td>
<td style="text-align:center">⛔️</td>
<td style="text-align:center">⛔️</td>
</tr>
<tr>
<td style="text-align:left">支持 Kotlin 和 Java</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">⛔️</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:left">代码量</td>
<td style="text-align:center">❤️</td>
<td style="text-align:center">💔</td>
<td style="text-align:center">❤️</td>
<td style="text-align:center">💔</td>
</tr>
</tbody>
</table>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在 <code>build.gradle</code> 中声明使用 ViewBinding</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Android Studio 3.6</span></span><br><span class="line">android &#123;</span><br><span class="line">    viewBinding &#123;</span><br><span class="line">        enabled = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在 Android Stduio 4.0 中，ViewBinding 已经移入<code>buildFeatures</code> 中了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Android Studio 4.0</span><br><span class="line">android &#123;</span><br><span class="line">    buildFeatures &#123;</span><br><span class="line">        viewBinding = true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明后，根据你的 xml 命名动态生成 **Binding，例如 activity_home 就会生成 ActivityHomeBinding</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityHomeBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    binding = ActivityHomeBinding.inflate(layoutInflater)</span><br><span class="line">    <span class="keyword">val</span> view = binding.root</span><br><span class="line">    setContentView(view)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你已经 inflate 了 xml，那也可以使用 <code>bind(view)</code> 将 ViewBinding 和 view 绑定，这便于我们对自定义 View 进行重构。</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>从去年年底开始，我就在 Android Studio 3.6 preview 版本上使用 ViewBinding 开发了。下面分享一下项目内的实践思路。</p>
<h4 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h4><p>最经常使用的 Fragment，我创建了 BindingFragment</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingFragment</span>&lt;<span class="type">T : ViewBinding</span>&gt; : <span class="type">BaseFragment</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="function"><span class="params">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>: View? &#123;</span><br><span class="line">        initData().invoke(arguments ?: Bundle())</span><br><span class="line">        binding = createBinding().invoke(inflater, container, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span> binding.root</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">        setupView().invoke(binding)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">createBinding</span><span class="params">()</span></span>: (</span><br><span class="line">        inflater: LayoutInflater,</span><br><span class="line">        container: ViewGroup?,</span><br><span class="line">        attachToRoot: <span class="built_in">Boolean</span></span><br><span class="line">    ) -&gt; T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">initData</span><span class="params">()</span></span>: Bundle.() -&gt; <span class="built_in">Unit</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">setupView</span><span class="params">()</span></span>: T.() -&gt; <span class="built_in">Unit</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">ctx</span><span class="params">()</span></span>: Context = binding.root.context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类使用</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeFragment</span> : <span class="type">BindingFragment</span>&lt;<span class="type">FragmentHomeBinding</span>&gt;</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createBinding</span><span class="params">()</span></span>: (</span><br><span class="line">        inflater: LayoutInflater,</span><br><span class="line">        container: ViewGroup?,</span><br><span class="line">        attachToRoot: <span class="built_in">Boolean</span></span><br><span class="line">    ) -&gt; FragmentHomeBinding &#123;</span><br><span class="line">        <span class="keyword">return</span> FragmentHomeBinding::inflate</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">setupView</span><span class="params">()</span></span>: FragmentHomeBinding.() -&gt; <span class="built_in">Unit</span> = &#123;</span><br><span class="line">        tvContent.text = <span class="string">"ViewBinding is cool"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于子类，我只需要关心 <code>fragment_home.xml</code> 生成的 <code>FragmentHomeBinding</code>，不需要额外对 <code>R.layout.fragment_home</code> 进行处理。在 <code>setupView</code> 中我可以直接使用 <code>tvContent</code>  的引用，就像在使用 <code>kotlin Synthetics</code> 一样。</p>
<h4 id="View"><a href="#View" class="headerlink" title="View"></a>View</h4><p>自定义 View 也是经常使用的，这里有两种使用思路</p>
<p>先用 View#inflate 绑定 XML 后，再用 ViewBinding#bind 绑定 View，这样就可以使用 ViewBinding 来渲染相应的 UI，这种方式方便我们重构已经写好的 View：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmptyView</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    context: Context, attrs: AttributeSet? = <span class="literal">null</span>, defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : ConstraintLayout(context, attrs, defStyleAttr) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> binding: ViewEmptyBinding</span><br><span class="line">    </span><br><span class="line">    init &#123;</span><br><span class="line">        View.inflate(context, R.layout.view_empty, <span class="keyword">this</span>)</span><br><span class="line">        binding = ViewEmptyBinding.bind(<span class="keyword">this</span>)</span><br><span class="line">        binding.apply &#123;</span><br><span class="line">            tvTitle.text = <span class="string">"Data is emtpy"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种是使用 ViewBinding#inflate，这种就不用关心 <code>R.layout.view_emty</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmptyView</span> <span class="meta">@JvmOverloads</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    context: Context, attrs: AttributeSet? = <span class="literal">null</span>, defStyleAttr: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : ConstraintLayout(context, attrs, defStyleAttr) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> binding = ViewEmptyBinding.inflate(LayoutInflater.from(context), <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        binding.apply &#123;</span><br><span class="line">            tvTitle.text = <span class="string">"Data is emtpy"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h4><p>项目里的 Adapter 是基于第三方库进行封装的，这里提供一种基于 RecyclerView#Adapter 的封装作为参考：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingViewHolder</span>&lt;<span class="type">VB : ViewBinding</span>&gt;</span>(<span class="keyword">val</span> vb: VB) : RecyclerView.ViewHolder(vb.root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingAdapter</span>&lt;<span class="type">VB : ViewBinding, T</span>&gt; : <span class="type">RecyclerView.Adapter</span>&lt;<span class="type">BindingViewHolder&lt;VB</span>&gt;&gt;</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: MutableList&lt;T&gt; = arrayListOf()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: BindingViewHolder&lt;VB&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingViewHolder(</span><br><span class="line">            createBinding().invoke(LayoutInflater.from(parent.context), parent, <span class="literal">false</span>)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> = <span class="keyword">data</span>.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">BindingViewHolder</span>&lt;<span class="type">VB</span>&gt;, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">data</span>.getOrNull(position)?.apply &#123; </span><br><span class="line">            update(<span class="keyword">this</span>).invoke(holder.vb)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">createBinding</span><span class="params">()</span></span>: (</span><br><span class="line">        inflater: LayoutInflater,</span><br><span class="line">        container: ViewGroup?,</span><br><span class="line">        attachToRoot: <span class="built_in">Boolean</span></span><br><span class="line">    ) -&gt; VB</span><br><span class="line"></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(item: <span class="type">T</span>)</span></span>: VB.() -&gt; <span class="built_in">Unit</span> = &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现思路也是和 Fragment 类似的，Adapter 的子类是需要是实现 createBinding 就可以实现相应的逻辑。这里仅提供一个简单的例子，目前这个封装还解决不了多布局的问题。如果需要解决多布局的问题还需要基于 ViewHolder 进行封装，聪明的你能想出来么？</p>
<p>看完了我们上面三个的封装，你会发现，我尽量都是让 ViewBinding 去替换掉我原先使用 <code>R.layout.xxx</code> 的地方。尽量用 ViewBinding 来替换 xml 的调用，让调用方只关心 ViewBinding 就可以写好代码。不好就是 lint 检查的时候会发现我有大量的 xml 没有使用😂</p>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>前面是聊了这么久 ViewBinding 的优点，我们再来讲讲它的缺点：</p>
<p>首先是调用方式的不友好。他的引用依赖于 binding 的实力，这点使用 apply 或 run 有所缓解</p>
<p>其次就是对 include 标签的不友好。在其他的使用中，即便我们不给 inlcude 加标签，我们也可以使用。而使用了 Viewbinding，对于 include 你只能 binding.inlcudeId.widgetId， 如果 inlcude 里面还有 inlcude ，就只能不停地套娃；再者，如果 inlcude 使用了 merge 的标签，你还需要使用 InlcudeBinding.bind(bingding.includeId) 来进行绑定，否则就会报错</p>
<p>最后是重复命名的不友好。如果外部不小心调动了和 include 内部或者自定义 View 内部一样的 id，那么这个 widget 的引用将会失效，而且程序不会崩溃。这种隐藏的问题只有程序运行到那里并且发现 UI 异常才能被发现，希望 Google 之后能修复这个问题</p>
<p>###总结</p>
<p>对我来说，ViewBinding 还是蛮甜的，由于是 Binding 的引用，每处的调用我会相对比较有安全感，不用担心代码的出错。使用 Binding 对象感觉也比较安全。推荐你使用 ViewBinding 来调用你的 widget。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/03/10/大图加载器 TileView 实践探索（上）/" class="next">下一篇</a></div><div class="copyright"><p>© 2017 - 2020 <a href="http://yoursite.com">文钦</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>